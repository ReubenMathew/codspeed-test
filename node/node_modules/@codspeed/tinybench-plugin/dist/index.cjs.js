'use strict';

var core = require('@codspeed/core');
var path = require('node:path');
var node_url = require('node:url');
var process = require('node:process');
var fs = require('node:fs');
var path$1 = require('path');
var url = require('url');

const typeMappings = {
	directory: 'isDirectory',
	file: 'isFile',
};

function checkType(type) {
	if (Object.hasOwnProperty.call(typeMappings, type)) {
		return;
	}

	throw new Error(`Invalid type specified: ${type}`);
}

const matchType = (type, stat) => stat[typeMappings[type]]();

const toPath$1 = urlOrPath => urlOrPath instanceof URL ? node_url.fileURLToPath(urlOrPath) : urlOrPath;

function locatePathSync(
	paths,
	{
		cwd = process.cwd(),
		type = 'file',
		allowSymlinks = true,
	} = {},
) {
	checkType(type);
	cwd = toPath$1(cwd);

	const statFunction = allowSymlinks ? fs.statSync : fs.lstatSync;

	for (const path_ of paths) {
		try {
			const stat = statFunction(path.resolve(cwd, path_), {
				throwIfNoEntry: false,
			});

			if (!stat) {
				continue;
			}

			if (matchType(type, stat)) {
				return path_;
			}
		} catch {}
	}
}

const toPath = urlOrPath => urlOrPath instanceof URL ? node_url.fileURLToPath(urlOrPath) : urlOrPath;

const findUpStop = Symbol('findUpStop');

function findUpMultipleSync(name, options = {}) {
	let directory = path.resolve(toPath(options.cwd) || '');
	const {root} = path.parse(directory);
	const stopAt = options.stopAt || root;
	const limit = options.limit || Number.POSITIVE_INFINITY;
	const paths = [name].flat();

	const runMatcher = locateOptions => {
		if (typeof name !== 'function') {
			return locatePathSync(paths, locateOptions);
		}

		const foundPath = name(locateOptions.cwd);
		if (typeof foundPath === 'string') {
			return locatePathSync([foundPath], locateOptions);
		}

		return foundPath;
	};

	const matches = [];
	// eslint-disable-next-line no-constant-condition
	while (true) {
		const foundPath = runMatcher({...options, cwd: directory});

		if (foundPath === findUpStop) {
			break;
		}

		if (foundPath) {
			matches.push(path.resolve(directory, foundPath));
		}

		if (directory === stopAt || matches.length >= limit) {
			break;
		}

		directory = path.dirname(directory);
	}

	return matches;
}

function findUpSync(name, options = {}) {
	const matches = findUpMultipleSync(name, {...options, limit: 1});
	return matches[0];
}

function get(belowFn) {
  const oldLimit = Error.stackTraceLimit;
  Error.stackTraceLimit = Infinity;

  const dummyObject = {};

  const v8Handler = Error.prepareStackTrace;
  Error.prepareStackTrace = function(dummyObject, v8StackTrace) {
    return v8StackTrace;
  };
  Error.captureStackTrace(dummyObject, belowFn || get);

  const v8StackTrace = dummyObject.stack;
  Error.prepareStackTrace = v8Handler;
  Error.stackTraceLimit = oldLimit;

  return v8StackTrace;
}

function CallSite(properties) {
  for (const property in properties) {
    this[property] = properties[property];
  }
}

const strProperties = [
  'this',
  'typeName',
  'functionName',
  'methodName',
  'fileName',
  'lineNumber',
  'columnNumber',
  'function',
  'evalOrigin'
];

const boolProperties = [
  'topLevel',
  'eval',
  'native',
  'constructor'
];

strProperties.forEach(function (property) {
  CallSite.prototype[property] = null;
  CallSite.prototype['get' + property[0].toUpperCase() + property.substr(1)] = function () {
    return this[property];
  };
});

boolProperties.forEach(function (property) {
  CallSite.prototype[property] = false;
  CallSite.prototype['is' + property[0].toUpperCase() + property.substr(1)] = function () {
    return this[property];
  };
});

function isCodSpeedBenchOptions(options) {
  return "uri" in options;
}
function withCodSpeed(bench) {
  if (!core.Measurement.isInstrumented()) {
    const rawRun = bench.run;
    bench.run = async () => {
      console.warn(
        `[CodSpeed] ${bench.tasks.length} benches detected but no instrumentation found, falling back to tinybench`
      );
      return await rawRun.bind(bench)();
    };
    return bench;
  }
  const rawAdd = bench.add;
  bench.add = (name, fn, opts) => {
    const callingFile = getCallingFile();
    const uri = `${callingFile}::${name}`;
    const options = Object.assign({}, opts != null ? opts : {}, { uri });
    return rawAdd.bind(bench)(name, fn, options);
  };
  const rootCallingFile = getCallingFile();
  bench.run = async () => {
    core.setupCore();
    console.log(`[CodSpeed] running with @codspeed/tinybench v${"2.0.0"}`);
    for (const task of bench.tasks) {
      const uri = isCodSpeedBenchOptions(task.opts) ? task.opts.uri : `${rootCallingFile}::${task.name}`;
      await core.optimizeFunction(task.fn);
      await async function __codspeed_root_frame__() {
        core.Measurement.startInstrumentation();
        await task.fn();
        core.Measurement.stopInstrumentation(uri);
      }();
      console.log(`    \u2714 Measured ${uri}`);
    }
    console.log(`[CodSpeed] Done running ${bench.tasks.length} benches.`);
    return bench.tasks;
  };
  core.teardownCore();
  return bench;
}
function getCallingFile() {
  const stack = get();
  let callingFile = stack[2].getFileName();
  const gitDir = getGitDir(callingFile);
  if (gitDir === void 0) {
    throw new Error("Could not find a git repository");
  }
  if (callingFile.startsWith("file://")) {
    callingFile = url.fileURLToPath(callingFile);
  }
  return path$1.relative(gitDir, callingFile);
}
function getGitDir(path2) {
  const dotGitPath = findUpSync(".git", {
    cwd: path2,
    type: "directory"
  });
  return dotGitPath ? path$1.dirname(dotGitPath) : void 0;
}

exports.withCodSpeed = withCodSpeed;
//# sourceMappingURL=index.cjs.js.map
