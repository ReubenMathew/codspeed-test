import { writeFileSync } from 'fs';
import path from 'path';

const getV8Flags = (nodeVersionMajor) => {
  const flags = [
    "--hash-seed=1",
    "--random-seed=1",
    "--no-opt",
    "--predictable",
    "--predictable-gc-schedule",
    "--interpreted-frames-native-stack"
  ];
  if (nodeVersionMajor < 18) {
    flags.push("--no-randomize-hashes");
  }
  if (nodeVersionMajor < 20) {
    flags.push("--no-scavenge-task");
  }
  return flags;
};
const tryIntrospect = () => {
  if (process.env.__CODSPEED_NODE_CORE_INTROSPECTION_PATH__ !== void 0) {
    const nodeVersionMajor = parseInt(process.version.slice(1).split(".")[0]);
    const introspectionMetadata = {
      flags: getV8Flags(nodeVersionMajor)
    };
    writeFileSync(
      process.env.__CODSPEED_NODE_CORE_INTROSPECTION_PATH__,
      JSON.stringify(introspectionMetadata)
    );
    process.exit(0);
  }
};

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
let native_core;
try {
  const nativeCore = require("node-gyp-build")(
    path.dirname(__dirname)
  );
  native_core = __spreadProps(__spreadValues({}, nativeCore), {
    isBound: true
  });
} catch (e) {
  native_core = {
    Measurement: {
      isInstrumented: () => false,
      // eslint-disable-next-line @typescript-eslint/no-empty-function
      startInstrumentation: () => {
      },
      // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-empty-function
      stopInstrumentation: (at) => {
      }
    },
    LinuxPerf: class LinuxPerf {
      start() {
        return false;
      }
      stop() {
        return false;
      }
    },
    isBound: false
  };
}
var native_core$1 = native_core;

const skipOptimization = process.env.CODSPEED_FORCE_OPTIMIZATION !== "true";
const initOptimization = () => {
  if (!skipOptimization) {
    require("v8").setFlagsFromString("--allow-natives-syntax");
  }
};
const optimizeFunction = async (fn) => {
  if (skipOptimization) {
    await fn();
    return;
  }
  await fn();
  await fn();
  eval("%OptimizeFunctionOnNextCall(fn)");
  await fn();
};
const optimizeFunctionSync = (fn) => {
  if (skipOptimization) {
    fn();
    return;
  }
  fn();
  fn();
  eval("%OptimizeFunctionOnNextCall(fn)");
  fn();
};

tryIntrospect();
const linuxPerf = new native_core$1.LinuxPerf();
const isBound = native_core$1.isBound;
const setupCore = () => {
  initOptimization();
  native_core$1.Measurement.stopInstrumentation(
    `Metadata: codspeed-node ${"2.0.0"}`
  );
  linuxPerf.start();
};
const teardownCore = () => {
  linuxPerf.stop();
};
const Measurement = native_core$1.Measurement;

export { Measurement, isBound, optimizeFunction, optimizeFunctionSync, setupCore, teardownCore };
//# sourceMappingURL=index.es5.js.map
